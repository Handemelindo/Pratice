#lang racket
(require rackunit)

;;nbfold : Val x (Val x Val -> Val) x List -> Val
;;usage: (nbfold z append lst) = the value generated by compact all elements in lst by append form z
(define nbfold
  (lambda (z append lst)
    (if (null? lst)
        z
        (nbfold
         (append z (car lst))
         append
         (cdr lst)))))
;;sum : Listof(Int) -> Int
;;usage: (sum lst) = the sum of all element in that list
(define sum
  (lambda (lst)
    (nbfold 0 (lambda (x y) (+ x y)) lst)))
(define flatMap
  (lambda (f lst)
    (if (null? lst)
        '()
        (append
         (f (car lst))
         (flatMap f (cdr lst))))))
;;invert-list : List x List -> List
;;usage (invert-list lst acc) = a new list starts with acc followed by lst with reverse order.
(define invert-list
  (lambda (lst acc)
    (if (null? lst)
        acc
        (invert-list
         (cdr lst)
         (cons (car lst) acc)))))

;;1.15[*]
;;duple: Int x Val -> Listof(Val)
;;usage (duple n x) = a list with n copies of x
(define duple
  (lambda (n x)
    (if (zero? n)
        '()
        (cons
         x
         (duple (- n 1) x)))))
(check-equal? (duple 2 3) '(3 3))
(check-equal? (duple 4 '(ha ha)) '((ha ha) (ha ha) (ha ha) (ha ha)))
(check-equal? (duple 0 '(blah)) '())
(check-equal? (duple 4 '()) '(() () () ()))

;;1.16[*]
;;invert : List -> List
;;usage : (invert lst) = a list in oppsite order
(define invert
  (lambda (lst)
    (map (lambda (lst) (invert-list lst '())) lst)))
(check-equal? (invert '((a 1) (a 2) (1 b) (2 b))) '((1 a) (2 a) (b 1) (b 2)))

;;1.17[*]
;;down : List -> List
;;usage: (down lst) = the same list but the top level elements are parenthesed.
(define down
  (lambda (lst)
    (map (lambda (x) (list x)) lst)))
(check-equal? (down '(1 2 3)) '((1) (2) (3)))
(check-equal? (down '((a) (fine) (idea))) '(((a)) ((fine)) ((idea))))
(check-equal? (down '(a (more (complicated)) object)) '((a) ((more (complicated))) (object)))

;;1.18[*]
;;swapper : Sym x Sym x S-list -> S-list
;;usage (swapper s1 s2 slist)
(define swapper
  (lambda (s1 s2 slist)
    (map
     (lambda (s)
       (if (symbol? s)
           (cond
            ((eqv? s s1) s2)
            ((eqv? s s2) s1)
            (else s))
           (swapper s1 s2 s)))
     slist)))
(check-equal? (swapper 'a 'd '(a b c d)) '(d b c a))
(check-equal? (swapper 'a 'd '(a d () c d)) '(d a () c a))
(check-equal? (swapper 'x 'y '((x) y (z (x)))) '((y) x (z (y))))

;;1.19[**]
;;list-set : List x Int x Val -> List
;;usage: (list-set lst n x) = a same list except the 0 based n-th elements is replaced by x
(define list-set
  (lambda (lst n x)
    (cond
     ;; should be an exception
     ((null? lst) '())
     ((zero? n) (cons x (cdr lst)))
     (else (cons (car lst) (list-set (cdr lst) (- n 1) x))))))

;;1.20[*]
;;count-occurrences : Sum x S-list -> Int
;;usage: (count-occurrence s slist) = the count of occurrence of s in slist
(define count-occurrences
  (lambda (s slist)
    (sum (map
          (lambda (sym)
            (if (symbol? sym)
                (if (eqv? sym s) 1 0)
                (count-occurrences s sym)))
          slist))))
(check-equal? (count-occurrences 'x '((f x) y (((x z) x)))) '3)
(check-equal? (count-occurrences 'x '((f x) y (((x z) () x)))) '3)
(check-equal? (count-occurrences 'w '((f x) y (((x z) x)))) '0)

;;1.21[**]
;;product : Listof(Sym) x Listof(Sym) -> Listof(Sym)
;;usage: (product sos1 sos2) = a list of symbols contains the cartesian product of sos1 and sos2
(define product
  (lambda (sos1 sos2)
    (flatMap (lambda (sym1)
           (map (lambda (sym2)
                  (list sym1 sym2)) sos2)) sos1)))
(check-equal? (product '(a b c) '(x y)) '((a x) (a y) (b x) (b y) (c x) (c y)))

;;1.22[**]
;;filter-in : Prediction x List -> List
;;usage: (filter-in pred lst) = a list of all elements in lst that satisfy the predicate pred.
(define filter-in
  (lambda (pred lst)
    (invert-list
     (nbfold
       '()
       (lambda (x y)
         (if (pred y)
             (if (null? x) (list y) (cons y x))
             x))
       lst)
     '()
     )))
(check-equal? (filter-in number? '(a 2 (1 3) b 7)) '(2 7))
(check-equal? (filter-in symbol? '(a (b c) 17 foo)) '(a foo))

;;1.23[**]
;;list-index : Prediction x lst
;;usage: (list-index pred lst) = the 0 based index of the element
;;that satisfy the prediciton pred first. if no element sastifies, return #f
(define list-index
  (lambda (pred lst)
    (list-index-from pred lst 0)))
(define list-index-from
  (lambda (pred lst from)
    (cond
     ((null? lst) #f)
     ((pred (car lst)) from)
     (else (list-index-from pred (cdr lst) (+ 1 from))))))
(check-equal? (list-index number? '(a 2 (1 3) b 7)) 1)
(check-equal? (list-index symbol? '(a (b c) 17 foo)) 0)
(check-equal? (list-index symbol? '(1 2 (a b) 3)) #f)

;;1.24[**]
;;every? : Prediction x List -> Bool
;;usage: (every? pred lst) = true if all elements sastifies the prediction pre,
;;else or empty return #f.
(define every?
  (lambda (pred lst)
    (cond
     ((null? lst) #t)
     ((not (pred (car lst))) #f)
     (else (every? pred (cdr lst))))))
(check-equal? (every? number? '(a b c 3 e)) '#f)
(check-equal? (every? number? '(1 2 3 5 4)) '#t)

;;1.25[**]
;;exists? : Prediction x List -> Bool
;;usage: (exists? pred lst) = true if
(define exists?
  (lambda (pred lst)
    (cond
     ((null? lst) #f)
     ((pred (car lst)) #t)
     (else (exists? pred (cdr lst))))))
(check-equal? (exists? number? '(a b c 3 e)) '#t)
(check-equal? (exists? number? '(a b c d e)) '#f)

;;1.26[**]
;;up : List -> List
;;usage: (up lst) = flatten the element one level
(define up
  (lambda (lst)
    (nbfold
     '()
     (lambda (x y)
       (if (list? y)
           (append x y)
           (append x (list y))))
     lst)))
(check-equal? (up '((1 2) (3 4))) '(1 2 3 4))
(check-equal? (up '((x (y)) z)) '(x (y) z))

;;1.27[**]
;;flatten : List -> List
;;usage: (flatten lst) = return the one level list contains all elements in the original list.
(define flatten
  (lambda (lst)
    (nbfold
     '()
     (lambda (x y)
       (if (list? y)
           (append x (flatten y))
           (append x (list y))))
     lst)))
(check-equal? (flatten '(a b c)) '(a b c))
(check-equal? (flatten '((a () (b  ()) () (c)))) '(a b c))
(check-equal? (flatten '((a b) c (((d)) e))) '(a b c d e))
(check-equal? (flatten '(a b (() (c)))) '(a b c))

;;1.28[**]
;;merge : Listof[Int] x Listof[Int] -> Listof[Int]
;;usage: (merge loi1 loi2) = merge two sorted list of integer loi1 and loi2 to one sorted list.
(define merge
  (lambda (loi1 loi2)
    (cond
     ((null? loi1) loi2)
     ((null? loi2) loi1)
     ((< (car loi1) (car loi2))
      (cons (car loi1) (merge (cdr loi1) loi2)))
     (else
      (cons (car loi2) (merge loi1 (cdr loi2)))))))
(check-equal? (merge '(1 4) '(1 2 8)) '(1 1 2 4 8))
(check-equal? (merge '(35 62 81 90 91) '(3 83 85 90)) '(3 35 62 81 83 85 90 90 91))

;;1.29[**]
;;sort : Listof[Int] -> Listof[Int]
;;usage: (sort lst) = sort the list in ascending order.
(define sort
  (lambda (lst)
    (nbfold '() (lambda (x y) (insert x < y)) lst)))
(define insert
  (lambda (lst ord n)
    (cond
     ((null? lst) (list n))
     ((not (ord (car lst) n)) (cons n lst))
     (else (cons (car lst) (insert (cdr lst) ord n))))))
(check-equal? (sort '(8 2 5 2 3)) '(2 2 3 5 8))

;;1.30[**]
;;sort/predicate : Prediction x Listof[Int] -> Listof[Int]
;;usage: (sort/predicate ord loi) = sort the list by the given ord.
(define sort/predicate
  (lambda (pred loi)
    (nbfold '() (lambda (x y) (insert x pred y)) loi)))
(check-equal? (sort/predicate < '(8 2 5 2 3)) '(2 2 3 5 8))
(check-equal? (sort/predicate > '(8 2 5 2 3)) '(8 5 3 2 2))

;;1.31[*]
;;leaf: Val -> Leaf(Val)
;;usage: (leaf x) = a leaf of value x
(define leaf
  (lambda (x) (list x)))

;;interior-node : Val x Tree(Val) x Tree(Val) -> Node(Val, Tree(Val), Tree(Val))
;;usage: (interior-node x ls rs) = a node of x and contains two sons ls and rs.
(define interior-node
  (lambda (x ls rs)
    (list x ls rs)))

;;leaf? : Val -> Bool
;;usage: (leaf? x) = #t if x is a leaf.
(define leaf?
  (lambda (x)
    (and (not (null? x))
         (null? (cdr x)))))

;;lson : Tree(Val) -> Tree(Val)
;;usage: (lson tree) = the left son of the tree
(define lson
  (lambda (tree) (cadr tree)))

;;rson : Tree(Val) -> Tree(Val)
;;usage: (rson tree) = the left son of the tree
(define rson
  (lambda (tree) (caddr tree)))

;;contents-of : Tree(Val) -> Val
;;usage: (contents-of tree) = the value hold by the root of this tree
(define contents-of
  (lambda (tree) (car tree)))

;;1.32[*]
;;double-tree: Tree(Val) -> Val
;;usage (double-tree tree) = a copy of the original tree except all values are doubled
(define double-tree
  (lambda (tree)
    (if (leaf? tree)
        (leaf (* 2 (contents-of tree)))
        (interior-node (* 2 (contents-of tree))
         (double-tree (lson tree))
         (double-tree (rson tree))))))

;;TODO
;;1.33[**]
;;mark-leaves-with-red-depth:

;;1.34[***]
;;path: Tree(Int) -> Listof(left | right)
;;usage: (path bst) = return the path we walk through while searching the value
;;in the binary search that contains the value
(define path
  (lambda (n bst)
    (cond
     ((eqv? n (contents-of bst)) '())
     ((< n (contents-of bst)) (cons 'left (path n (lson bst))))
     (else (cons 'right (path n (rson bst)))))))
(check-equal?
 (path 17 '(14 (7 () (12 () ()))
               (26 (20 (17 () ())
                       ())
                   (31 () ()))))
 '(right left left))

;;1.35[***]
;;number-leaves-from : Tree -> Tree
;;usage: (number-leaves-from tree n) = a tree which labeled by dfs order from n.
(define number-leaves-from
  (lambda (tree n)
    (if (leaf? tree)
        ((leaf n) (+ n 1))
        (let
            ((labeled-lson (number-leaves-from (lson tree) n)))
          (let
              ((labeled-rson (number-leaves-from (rson tree) (cdr labeled-lson))))
            (interior-node (contents-of tree) labeled-lson labeled-rson))))))

(define number-leaves
  (lambda (tree) (number-leaves-from tree 0)))

;;1.36[***]
(define number-elements-from
  (lambda (lst n)
    (if (null? lst) '()
        (cons
         (list n (car lst))
         (number-elements-from (cdr lst) (+ n 1))))))

;; (define number-elements
;;   (lambda (lst)
;;     (if (null? lst) '()
;;         (g
;;          (list 0 (car lst))
;;          (number-elements (cdr lst))))))
;; (define g
;;   (lambda (pair lst)
;;     ))
